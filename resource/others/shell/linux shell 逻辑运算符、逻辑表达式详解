 linux shell 逻辑运算符、逻辑表达式详解

shell的逻辑运算符 涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。

 

一、逻辑运算符

 

 

 
逻辑卷标 	表示意思
1. 	关于档案与目录的侦测逻辑卷标！
-f 	常用！侦测『档案』是否存在 eg: if [ -f filename ]
-d 	常用！侦测『目录』是否存在
-b 	侦测是否为一个『 block 档案』
-c 	侦测是否为一个『 character 档案』
-S 	侦测是否为一个『 socket 标签档案』
-L 	侦测是否为一个『 symbolic link 的档案』
-e 	侦测『某个东西』是否存在！
2. 	关于程序的逻辑卷标！
-G 	侦测是否由 GID 所执行的程序所拥有
-O 	侦测是否由 UID 所执行的程序所拥有
-p 	侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）
3. 	关于档案的属性侦测！
-r 	侦测是否为可读的属性
-w 	侦测是否为可以写入的属性
-x 	侦测是否为可执行的属性
-s 	侦测是否为『非空白档案』
-u 	侦测是否具有『 SUID 』的属性
-g 	侦测是否具有『 SGID 』的属性
-k 	侦测是否具有『 sticky bit 』的属性
4. 	两个档案之间的判断与比较 ；例如[ test file1 -nt file2 ]
-nt 	第一个档案比第二个档案新
-ot 	第一个档案比第二个档案旧
-ef 	第一个档案与第二个档案为同一个档案（ link 之类的档案）
5. 	逻辑的『和(and)』『或(or)』
&& 	逻辑的 AND 的意思
|| 	逻辑的 OR 的意思

  

 
运算符号 	代表意义
= 	等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
!= 	不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
< 	小于 应用于：整型比较 在[] 中，不能使用 表示字符串
> 	大于 应用于：整型比较 在[] 中，不能使用 表示字符串
-eq 	等于 应用于：整型比较
-ne 	不等于 应用于：整型比较
-lt 	小于 应用于：整型比较
-gt 	大于 应用于：整型比较
-le 	小于或等于 应用于：整型比较
-ge 	大于或等于 应用于：整型比较
-a 	双方都成立（and） 逻辑表达式 –a 逻辑表达式
-o 	单方成立（or） 逻辑表达式 –o 逻辑表达式
-z 	空字符串
-n 	非空字符串

 

二、逻辑表达式

 

    test 命令 

    使用方法：test EXPRESSION

    如：

    [root@localhost ~]# test 1 = 1 && echo 'ok'
    ok

    [root@localhost ~]# test -d /etc/ && echo 'ok'
    ok

    [root@localhost ~]# test 1 -eq 1 && echo 'ok'
    ok

     

    [root@localhost ~]# if test 1 = 1 ; then echo 'ok'; fi
    ok

 

    注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。

 

    精简表达式 

        [] 表达式 

    [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'          
    ok

    [root@localhost ~]# [ 2 < 1 ] && echo 'ok'                 
    -bash: 2: No such file or directory

    [root@localhost ~]# [ 2 \< 1 ] && echo 'ok'

    [root@localhost ~]# [ 2 -gt 1 -a 3 -lt 4 ] && echo 'ok'

    ok    

    [root@localhost ~]# [ 2 -gt 1 && 3 -lt 4 ] && echo 'ok'  
    -bash: [: missing `]'

    注意：在[] 表达式中，常见的>,<需要加转义字符，表示字符串大小比较，以acill码 位置作为比较。 不直接支持<>运算符，还有逻辑运算符|| && 它需要用-a[and] –o[or]表示

 

     

     

        [[]] 表达式 

    [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'          
    ok

    [root@localhost ~]$ [[ 2 < 3 ]] && echo 'ok'
    ok
    [root@localhost ~]$ [[ 2 < 3 && 4 > 5 ]] && echo 'ok'
    ok

    注意：[[]] 运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：|| &&

     

 

三、性能比较

bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if [];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容><之类的运算符。以下是比较它们性能，发现[[]]是最快的。


$ time (for m in {1..100000}; do test -d .;done;)
real    0m0.658s
user    0m0.558s
sys     0m0.100s


$ time (for m in {1..100000}; do [ -d . ];done;)
real    0m0.609s
user    0m0.524s
sys     0m0.085s


$ time (for m in {1..100000}; do [[ -d . ]];done;)
real    0m0.311s
user    0m0.275s
sys     0m0.036s


不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符。

from: http://www.cnblogs.com/chengmo/archive/2010/10/01/1839942.html