from: http://www.diveintopython.net/toc/index.html

1. Installing Python
	1.5. Python on RedHat Linux
	1.8. The Interactive Shell
		Python leads a double life. It's an interpreter for scripts that you can run from the command line or run like applications, by double-clicking the scripts. 
		But it's also an interactive shell that can evaluate arbitrary statements and expressions.
		
		The Python interactive shell can evaluate arbitrary Python expressions, including any basic arithmetic expression.
		The interactive shell can execute arbitrary Python statements, including the print statement.
		You can also assign values to variables, and the values will be remembered as long as the shell is open (but not any longer than that).
2. Your First Python Program
	2.2. Declaring Functions
		2.2.1. How Python's Datatypes Compare to Other Programming Languages
			- the keyword def starts the function declaration, followed by the function name, followed by the arguments in parentheses. Multiple arguments (not shown here) are separated with commas.
			- function doesn't define a return datatype.Python functions do not specify the datatype of their return value; they don't even specify whether or not they return a value. In fact, 
		every Python function returns a value; if the function ever executes a return statement, it will return that value, otherwise it will return None, the Python null value.
			- The argument, params, doesn't specify a datatype. In Python, variables are never explicitly typed. Python figures out what type a variable is and keeps track of it internally.
		VBScript and Python are dynamically typed, because they figure out what type a variable is when you first assign it a value. Java and Python are strongly typed. 
		If you have an integer, you can't treat it like a string without explicitly converting it.
	2.3. Documenting Functions 文档注释
		def buildConnectionString(params):
		    """Build a connection string from a dictionary of parameters.

		    Returns string."""		
			Triple quotes signify a multi-line string. Everything between the start and end quotes is part of a single string, including carriage returns and other quote characters. You can use them anywhere, 
		 but you'll see them most often used when defining a doc string.
	2.4. Everything Is an Object
		A function, like everything else in Python, is an object.
		2.4.1. The Import Search Path
			Python looks in several places when you try to import a module. Specifically, it looks in all the directories defined in sys.path. This is just a list, and you can easily view it or modify it with standard list methods.
			eg:
				>>> import sys                 
				>>> sys.path                   
				['', '/usr/local/lib/python2.2', '/usr/local/lib/python2.2/plat-linux2', 
				'/usr/local/lib/python2.2/lib-dynload', '/usr/local/lib/python2.2/site-packages', 
				'/usr/local/lib/python2.2/site-packages/PIL', '/usr/local/lib/python2.2/site-packages/piddle']
				>>> sys                        
				<module 'sys' (built-in)>
				>>> sys.path.append('/my/new/path') 

			module means directory,eg:
				>>>from src import apihelper
				>>>apihelper.info("")

		2.4.2. What's an Object?
				Everything in Python is an object, and almost everything has attributes and methods. All functions have a built-in attribute __doc__, which returns the doc string defined in the function's source code. 
			The sys module is an object which has (among other things) an attribute called path. And so forth.
				Lists are objects. Functions are objects. Even modules are objects.
	2.5. Indenting Code 代码缩进
			Python functions have no explicit begin or end, and no curly braces to mark where the function code starts and stops. The only delimiter(定界符) is a colon (:) and the indentation of the code itself.
			Code blocks are defined by their indentation. By "code block", I mean functions, if statements, for loops, while loops, and so forth. Indenting starts a block and unindenting ends it. 
		There are no explicit braces, brackets, or keywords. This means that whitespace is significant, and must be consistent.
		eg:
			def fib(n):                   
			    print 'n =', n            
			    if n > 1:                 
				return n * fib(n - 1)
			    else:                     
				print 'end of the line'
				return 1
	2.6. Testing Modules
			Python modules are objects and have several useful attributes.
			Here's an example that uses the if __name__ trick.
				if __name__ == "__main__":
			Modules are objects, and all modules have a built-in attribute __name__. A module's __name__ depends on how you're using the module. If you import the module, then __name__ is the module's filename, 
		 without a directory path or file extension. But you can also run the module directly as a standalone program, in which case __name__ will be a special default value, __main__：
				>>> import odbchelper
				>>> odbchelper.__name__
				'odbchelper'.
		Knowing this, you can design a test suite for your module within the module itself by putting it in this if statement. When you run the module directly, __name__ is __main__, so the test suite executes. 
		When you import the module, __name__ is something else, so the test suite is ignored. This makes it easier to develop and debug new modules before integrating them into a larger program.
3. Native Datatypes
	3.1. Introducing Dictionaries
		One of Python's built-in datatypes is the dictionary, which defines one-to-one relationships between keys and values.
		COMMENT: A dictionary in Python is like an instance of the Hashtable class in Java.
		3.1.1. Defining Dictionaries
			>>> d = {"server":"mpilgrim", "database":"master"} 
			>>> d
			{'server': 'mpilgrim', 'database': 'master'}
			>>> d["server"]                                    
			'mpilgrim'
			>>> d["database"]                                  
			'master'
			>>> d["mpilgrim"]         
			Traceback (innermost last):
			  File "<interactive input>", line 1, in ?
			KeyError: mpilgrim			
				- You can get values by key, but you can't get keys by value. So d["server"] is 'mpilgrim', but d["mpilgrim"] raises an exception, because 'mpilgrim' is not a key.
				or to use get method,it will return empty than error.
		3.1.2. Modifying Dictionaries
			Example 3.2. Modifying a Dictionary
				>>> d
				{'server': 'mpilgrim', 'database': 'master'}
				>>> d["database"] = "pubs" 
				>>> d
				{'server': 'mpilgrim', 'database': 'pubs'}
				>>> d["uid"] = "sa"        
				>>> d
				{'server': 'mpilgrim', 'uid': 'sa', 'database': 'pubs'}	
					- Dictionaries have no concept of order among elements. It is incorrect to say that the elements are “out of order”; they are simply unordered. 
					This is an important distinction that will annoy you when you want to access the elements of a dictionary in a specific, repeatable order (like alphabetical order by key). 
					There are ways of doing this, but they're not built into the dictionary.

			When working with dictionaries, you need to be aware that dictionary keys are case-sensitive.

			Example 3.3. Dictionary Keys Are Case-Sensitive
				>>> d = {}
				>>> d["key"] = "value"
				>>> d["key"] = "other value" 
				>>> d
				{'key': 'other value'}
				>>> d["Key"] = "third value" 
				>>> d
				{'Key': 'third value', 'key': 'other value'}

			Example 3.4. Mixing Datatypes in a Dictionary
				>>> d
				{'server': 'mpilgrim', 'uid': 'sa', 'database': 'pubs'}
				>>> d["retrycount"] = 3 
				>>> d
				{'server': 'mpilgrim', 'uid': 'sa', 'database': 'master', 'retrycount': 3}
				>>> d[42] = "douglas"   
				>>> d
				{'server': 'mpilgrim', 'uid': 'sa', 'database': 'master',
				42: 'douglas', 'retrycount': 3}
		3.1.3. Deleting Items From Dictionaries
			Example 3.5. Deleting Items from a Dictionary
				>>> d
				{'server': 'mpilgrim', 'uid': 'sa', 'database': 'master',
				42: 'douglas', 'retrycount': 3}
				>>> del d[42] 
				>>> d
				{'server': 'mpilgrim', 'uid': 'sa', 'database': 'master', 'retrycount': 3}
				>>> d.clear() 
				>>> d
				{}		
	3.2. Introducing Lists
			Lists are Python's workhorse datatype. If your only experience with lists is arrays in Visual Basic or (God forbid) the datastore in Powerbuilder, brace yourself for Python lists.
			A list in Python is much more than an array in Java (although it can be used as one if that's really all you want out of life). A better analogy would be to the ArrayList class, 
		which can hold arbitrary objects and can expand dynamically as new items are added.
		3.2.1. Defining Lists
			Example 3.6. Defining a List
				>>> li = ["a", "b", "mpilgrim", "z", "example"] 
				>>> li
				['a', 'b', 'mpilgrim', 'z', 'example']
				>>> li[0]                                       
				'a'
				>>> li[4]                                       
				'example'		
				- A list is an ordered set of elements enclosed in square brackets.
				- A list can be used like a zero-based array. The first element of any non-empty list is always li[0].
				- The last element of this five-element list is li[4], because lists are always zero-based.
			
			Example 3.7. Negative List Indices
				>>> li
				['a', 'b', 'mpilgrim', 'z', 'example']
				>>> li[-1] 
				'example'
				>>> li[-3] 
				'mpilgrim'
					- A negative index accesses elements from the end of the list counting backwards. The last element of any non-empty list is always li[-1].
					- If the negative index is confusing to you, think of it this way: li[-n] == li[len(li) - n]. So in this list, li[-3] == li[5 - 3] == li[2].
			
			Example 3.8. Slicing a List
				>>> li
				['a', 'b', 'mpilgrim', 'z', 'example']
				>>> li[1:3]  
				['b', 'mpilgrim']
				>>> li[1:-1] 
				['b', 'mpilgrim', 'z']
				>>> li[0:3]  
				['a', 'b', 'mpilgrim']		
					- You can get a subset of a list, called a “slice”, by specifying two indices. The return value is a new list containing all the elements of the list, in order, starting with the first slice index (in this case li[1]), 
					up to but not including the second slice index (in this case li[3]).
					- Slicing works if one or both of the slice indices is negative. If it helps, you can think of it this way: reading the list from left to right, the first slice index specifies the first element you want, 
					and the second slice index specifies the first element you don't want. The return value is everything in between.
					- Lists are zero-based, so li[0:3] returns the first three elements of the list, starting at li[0], up to but not including li[3].
				
			Example 3.9. Slicing Shorthand
				>>> li
				['a', 'b', 'mpilgrim', 'z', 'example']
				>>> li[:3] 
				['a', 'b', 'mpilgrim']
				>>> li[3:]  
				['z', 'example']
				>>> li[:]  
				['a', 'b', 'mpilgrim', 'z', 'example']
					- If the left slice index is 0, you can leave it out, and 0 is implied. So li[:3] is the same as li[0:3] from Example 3.8, “Slicing a List”.
					- Similarly, if the right slice index is the length of the list, you can leave it out. So li[3:] is the same as li[3:5], because this list has five elements.
					- Note the symmetry here. In this five-element list, li[:3] returns the first 3 elements, and li[3:] returns the last two elements. In fact, li[:n] will always return the first n elements, and li[n:] 
					will return the rest, regardless of the length of the list.
					- If both slice indices are left out, all elements of the list are included. But this is not the same as the original li list; it is a new list that happens to have all the same elements. li[:] is shorthand 
					for making a complete copy of a list.					
		3.2.2. Adding Elements to Lists
			Example 3.10. Adding Elements to a List
				>>> li
				['a', 'b', 'mpilgrim', 'z', 'example']
				>>> li.append("new")               
				>>> li
				['a', 'b', 'mpilgrim', 'z', 'example', 'new']
				>>> li.insert(2, "new")            
				>>> li
				['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new']
				>>> li.extend(["two", "elements"]) 
				>>> li
				['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']
					- append adds a single element to the end of the list.
					- insert inserts a single element into a list. The numeric argument is the index of the first element that gets bumped out of position. Note that list elements do not need to be unique; 
					there are now two separate elements with the value 'new', li[2] and li[6].
					- extend concatenates lists. Note that you do not call extend with multiple arguments; you call it with one argument, a list. In this case, that list has two elements.
		3.2.3. Searching Lists
			Example 3.12. Searching a List
				>>> li
				['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']
				>>> li.index("example") 
				5
				>>> li.index("new")     
				2
				>>> li.index("c")       
				Traceback (innermost last):
				  File "<interactive input>", line 1, in ?
				ValueError: list.index(x): x not in list
				>>> "c" in li           
				False
					- index finds the first occurrence of a value in the list and returns the index.
					- index finds the first occurrence of a value in the list. In this case, 'new' occurs twice in the list, in li[2] and li[6], but index will return only the first index, 2.
					- If the value is not found in the list, Python raises an exception. This is notably different from most languages, which will return some invalid index. 
					While this may seem annoying, it is a good thing, because it means your program will crash at the source of the problem, rather than later on when you try to use the invalid index.
					- To test whether a value is in the list, use in, which returns True if the value is found or False if it is not.

					- Before version 2.2.1, Python had no separate boolean datatype. To compensate for this, Python accepted almost anything in a boolean context (like an if statement), 
					according to the following rules:
						0 is false; all other numbers are true.
						An empty string ("") is false, all other strings are true.
						An empty list ([]) is false; all other lists are true.
						An empty tuple (()) is false; all other tuples are true.
						An empty dictionary ({}) is false; all other dictionaries are true.
					These rules still apply in Python 2.2.1 and beyond, but now you can also use an actual boolean, which has a value of True or False. Note the capitalization; these values, like everything else in Python, 
					are case-sensitive.
		3.2.4. Deleting List Elements
			Example 3.13. Removing Elements from a List
				>>> li
				['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']
				>>> li.remove("z")   
				>>> li
				['a', 'b', 'new', 'mpilgrim', 'example', 'new', 'two', 'elements']
				>>> li.remove("new") 
				>>> li
				['a', 'b', 'mpilgrim', 'example', 'new', 'two', 'elements']
				>>> li.remove("c")   
				Traceback (innermost last):
				  File "<interactive input>", line 1, in ?
				ValueError: list.remove(x): x not in list
				>>> li.pop()         
				'elements'
				>>> li
				['a', 'b', 'mpilgrim', 'example', 'new', 'two']
					- remove removes the first occurrence of a value from a list.
					- remove removes only the first occurrence of a value. In this case, 'new' appeared twice in the list, but li.remove("new") removed only the first occurrence.
					- If the value is not found in the list, Python raises an exception. This mirrors the behavior of the index method.
					- pop is an interesting beast. It does two things: it removes the last element of the list, and it returns the value that it removed. Note that this is different from li[-1], 
					which returns a value but does not change the list, and different from li.remove(value), which changes the list but does not return a value.
		3.2.5. Using List Operators
			Example 3.14. List Operators
				>>> li = ['a', 'b', 'mpilgrim']
				>>> li = li + ['example', 'new'] 
				>>> li
				['a', 'b', 'mpilgrim', 'example', 'new']
				>>> li += ['two']                
				>>> li
				['a', 'b', 'mpilgrim', 'example', 'new', 'two']
				>>> li = [1, 2] * 3              
				>>> li
				[1, 2, 1, 2, 1, 2]
					- Lists can also be concatenated with the + operator. list = list + otherlist has the same result as list.extend(otherlist). But the + operator returns a new (concatenated) list as a value, 
					whereas extend only alters an existing list. This means that extend is faster, especially for large lists.
					- Python supports the += operator. li += ['two'] is equivalent to li.extend(['two']). The += operator works for lists, strings, and integers, and it can be overloaded to work for user-defined classes 
					as well. (More on classes in Chapter 5.)
					- The * operator works on lists as a repeater. li = [1, 2] * 3 is equivalent to li = [1, 2] + [1, 2] + [1, 2], which concatenates the three lists into one.
	3.3. Introducing Tuples
		A tuple is an immutable list. A tuple can not be changed in any way once it is created.

		Example 3.15. Defining a tuple
			>>> t = ("a", "b", "mpilgrim", "z", "example") 
			>>> t
			('a', 'b', 'mpilgrim', 'z', 'example')
			>>> t[0]                                       
			'a'
			>>> t[-1]                                      
			'example'
			>>> t[1:3]                                     
			('b', 'mpilgrim')
				- A tuple is defined in the same way as a list, except that the whole set of elements is enclosed in parentheses instead of square brackets.
				- The elements of a tuple have a defined order, just like a list. Tuples indices are zero-based, just like a list, so the first element of a non-empty tuple is always t[0].
				- Negative indices count from the end of the tuple, just as with a list.
				- Slicing works too, just like a list. Note that when you slice a list, you get a new list; when you slice a tuple, you get a new tuple.

		Example 3.16. Tuples Have No Methods
			>>> t
			('a', 'b', 'mpilgrim', 'z', 'example')
			>>> t.append("new")    
			Traceback (innermost last):
			  File "<interactive input>", line 1, in ?
			AttributeError: 'tuple' object has no attribute 'append'
			>>> t.remove("z")      
			Traceback (innermost last):
			  File "<interactive input>", line 1, in ?
			AttributeError: 'tuple' object has no attribute 'remove'
			>>> t.index("example") 
			Traceback (innermost last):
			  File "<interactive input>", line 1, in ?
			AttributeError: 'tuple' object has no attribute 'index'
			>>> "z" in t           
			True
				- You can't add elements to a tuple. Tuples have no append or extend method.
				- You can't remove elements from a tuple. Tuples have no remove or pop method.
				- You can't find elements in a tuple. Tuples have no index method.
				- You can, however, use in to see if an element exists in the tuple.

		So what are tuples good for?
      			- Tuples are faster than lists. If you're defining a constant set of values and all you're ever going to do with it is iterate through it, use a tuple instead of a list.
			- It makes your code safer if you “write-protect” data that does not need to be changed. Using a tuple instead of a list is like having an implied assert statement 
			that shows this data is constant, and that special thought (and a specific function) is required to override that.
			- Remember that I said that dictionary keys can be integers, strings, and “a few other types”? Tuples are one of those types. Tuples can be used as keys in a dictionary, 
			but lists can't be used this way.Actually, it's more complicated than that. Dictionary keys must be immutable. Tuples themselves are immutable, but if you have a tuple of lists, 
			that counts as mutable and isn't safe to use as a dictionary key. Only tuples of strings, numbers, or other dictionary-safe tuples can be used as dictionary keys.
			- Tuples are used in string formatting, as you'll see shortly.

			Tuples can be converted into lists, and vice-versa. The built-in tuple function takes a list and returns a tuple with the same elements, and the list function takes a tuple and returns a list. 
		In effect, tuple freezes a list, and list thaws a tuple.

	3.4. Declaring variables
			Python has local and global variables like most other languages, but it has no explicit variable declarations. Variables spring into existence by being assigned a value, 
		and they are automatically destroyed when they go out of scope.

		Example 3.17. Defining the myParams Variable
			if __name__ == "__main__":
			    myParams = {"server":"mpilgrim", \
					"database":"master", \
					"uid":"sa", \
					"pwd":"secret" \
					}
			Notice the indentation. An if statement is a code block and needs to be indented just like a function.
			Also notice that the variable assignment is one command split over several lines, with a backslash (“\”) serving as a line-continuation marker.
			When a command is split among several lines with the line-continuation marker (“\”), the continued lines can be indented in any manner; Python's normally stringent indentation rules do not apply. 
		If your Python IDE auto-indents the continued line, you should probably accept its default unless you have a burning reason not to.
			Python will not allow you to reference a variable that has never been assigned a value; trying to do so will raise an exception.
		
		3.4.1. Referencing Variables
			Example 3.18. Referencing an Unbound Variable
				>>> x
				Traceback (innermost last):
				  File "<interactive input>", line 1, in ?
				NameError: There is no variable named 'x'
				>>> x = 1
				>>> x
				1
				You will thank Python for this one day.

		3.4.2. Assigning Multiple Values at Once
			One of the cooler programming shortcuts in Python is using sequences to assign multiple values at once.
			Example 3.19. Assigning multiple values at once
				>>> v = ('a', 'b', 'e')
				>>> (x, y, z) = v     
				>>> x
				'a'
				>>> y
				'b'
				>>> z
				'e'
					- v is a tuple of three elements, and (x, y, z) is a tuple of three variables. Assigning one to the other assigns each of the values of v to each of the variables, in order.
				This has all sorts of uses. I often want to assign names to a range of values. In C, you would use enum and manually list each constant and its associated value, which 
				seems especially tedious when the values are consecutive(连续的，连贯的). In Python, you can use the built-in range function with multi-variable assignment to quickly assign consecutive values.
	
			Example 3.20. Assigning Consecutive Values
				>>> range(7)                                                                    
				[0, 1, 2, 3, 4, 5, 6]
				>>> (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7) 
				>>> MONDAY                                                                      
				0
				>>> TUESDAY
				1
				>>> SUNDAY
				6
					- The built-in range function returns a list of integers. In its simplest form, it takes an upper limit and returns a zero-based list counting up to but not including the upper limit. 
					(If you like, you can pass other parameters to specify a base other than 0 and a step other than 1. You can print range.__doc__ for details.)
					- MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY are the variables you're defining. (This example came from the calendar module, 
					a fun little module that prints calendars, like the UNIX program cal. The calendar module defines integer constants for days of the week.)
					- Now each variable has its value: MONDAY is 0, TUESDAY is 1, and so forth.

       3.5. Formatting Strings
		Python supports formatting values into strings. Although this can include very complicated expressions, the most basic usage is to insert values into a string with the %s placeholder.
		Example 3.21. Introducing String Formatting
			>>> k = "uid"
			>>> v = "sa"
			>>> "%s=%s" % (k, v) 
			'uid=sa'
				- The whole expression evaluates to a string. The first %s is replaced by the value of k; the second %s is replaced by the value of v. All other characters in the string (
				in this case, the equal sign) stay as they are.
		Example 3.22. String Formatting vs. Concatenating
			>>> uid = "sa"
			>>> pwd = "secret"
			>>> print pwd + " is not a good password for " + uid      
			secret is not a good password for sa
			>>> print "%s is not a good password for %s" % (pwd, uid) 
			secret is not a good password for sa
			>>> userCount = 6
			>>> print "Users connected: %d" % (userCount, )            
			Users connected: 6
			>>> print "Users connected: " + userCount                 
			Traceback (innermost last):
			  File "<interactive input>", line 1, in ?
			TypeError: cannot concatenate 'str' and 'int' objects
				- + is the string concatenation operator.
				- In this trivial case, string formatting accomplishes the same result as concatentation.
				- (userCount, ) is a tuple with one element. Yes, the syntax is a little strange, but there's a good reason for it: it's unambiguously a tuple. In fact, you can always include a comma after 
				the last element when defining a list, tuple, or dictionary, but the comma is required when defining a tuple with one element. If the comma weren't required, Python wouldn't know whether
				(userCount) was a tuple with one element or just the value of userCount.
				- String formatting works with integers by specifying %d instead of %s.
				- Trying to concatenate a string with a non-string raises an exception. Unlike string formatting, string concatenation works only when everything is already a string.
		Example 3.23. Formatting Numbers
			>>> print "Today's stock price: %f" % 50.4625   
			50.462500
			>>> print "Today's stock price: %.2f" % 50.4625 
			50.46
			>>> print "Change since yesterday: %+.2f" % 1.5 
			+1.50
				- The %f string formatting option treats the value as a decimal, and prints it to six decimal places.
				- The ".2" modifier of the %f option truncates the value to two decimal places.
				- You can even combine modifiers. Adding the + modifier displays a plus or minus sign before the value. Note that the ".2" modifier is still in place, and is padding the value to exactly two decimal places.

	3.6. Mapping Lists
		One of the most powerful features of Python is the list comprehension, which provides a compact way of mapping a list into another list by applying a function to each of the elements of the list.

		Example 3.24. Introducing List Comprehensions
			>>> li = [1, 9, 8, 4]
			>>> [elem*2 for elem in li]      
			[2, 18, 16, 8]
			>>> li                           
			[1, 9, 8, 4]
			>>> li = [elem*2 for elem in li] 
			>>> li
			[2, 18, 16, 8]
				- To make sense of this, look at it from right to left. li is the list you're mapping. Python loops through li one element at a time, temporarily assigning the value of each element to the variable elem. 
				Python then applies the function elem*2 and appends that result to the returned list.
				- Note that list comprehensions do not change the original list.
				- It is safe to assign the result of a list comprehension to the variable that you're mapping. Python constructs the new list in memory, and when the list comprehension is complete, it assigns the result 
				to the variable.Here are the list comprehensions in the buildConnectionString function that you declared in Chapter 2:

			["%s=%s" % (k, v) for k, v in params.items()]
			First, notice that you're calling the items function of the params dictionary. This function returns a list of tuples of all the data in the dictionary.

		Example 3.25. The keys, values, and items Functions
			>>> params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}
			>>> params.keys()   
			['server', 'uid', 'database', 'pwd']
			>>> params.values() 
			['mpilgrim', 'sa', 'master', 'secret']
			>>> params.items()  
			[('server', 'mpilgrim'), ('uid', 'sa'), ('database', 'master'), ('pwd', 'secret')]
				- The keys method of a dictionary returns a list of all the keys. The list is not in the order in which the dictionary was defined (remember that elements in a dictionary are unordered), but it is a list.
				- The values method returns a list of all the values. The list is in the same order as the list returned by keys, so params.values()[n] == params[params.keys()[n]] for all values of n.
				- The items method returns a list of tuples of the form (key, value). The list contains all the data in the dictionary.
		
		Example 3.26. List Comprehensions in buildConnectionString, Step by Step
			>>> params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}
			>>> params.items()
			[('server', 'mpilgrim'), ('uid', 'sa'), ('database', 'master'), ('pwd', 'secret')]
			>>> [k for k, v in params.items()]                
			['server', 'uid', 'database', 'pwd']
			>>> [v for k, v in params.items()]                
			['mpilgrim', 'sa', 'master', 'secret']
			>>> ["%s=%s" % (k, v) for k, v in params.items()] 
			['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
	
	3.7. Joining Lists and Splitting Strings
		Example 3.27. Output of odbchelper.py
			>>> params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}
			>>> ["%s=%s" % (k, v) for k, v in params.items()]
			['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
			>>> ";".join(["%s=%s" % (k, v) for k, v in params.items()])
			'server=mpilgrim;uid=sa;database=master;pwd=secret'
		
		Example 3.28. Splitting a String
			>>> li = ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
			>>> s = ";".join(li)
			>>> s
			'server=mpilgrim;uid=sa;database=master;pwd=secret'
			>>> s.split(";")    
			['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
			>>> s.split(";", 1) 
			['server=mpilgrim', 'uid=sa;database=master;pwd=secret']
				- split reverses join by splitting a string into a multi-element list. Note that the delimiter (“;”) is stripped out completely; it does not appear in any of the elements of the returned list.
				- split takes an optional second argument, which is the number of times to split. (“"Oooooh, optional arguments...” You'll learn how to do this in your own functions in the next chapter.)

			anystring.split(delimiter, 1) is a useful technique when you want to search a string for a substring and then work with everything before the substring (which ends up in the first element of the returned list) 
			and everything after it (which ends up in the second element).

			ps:
				""" 类型转换
				"-".join([str(x) for x in li])
				li=[1,2,3]
				[str(x) for x in li] = ['1','2','3']
		3.7.1. Historical Note on String Methods
			When I first learned Python, I expected join to be a method of a list, which would take the delimiter as an argument. Many people feel the same way, and there's a story behind the join method. 
		Prior to Python 1.6, strings didn't have all these useful methods. There was a separate string module that contained all the string functions; each function took a string as its first argument. The functions 
		were deemed important enough to put onto the strings themselves, which made sense for functions like lower, upper, and split. But many hard-core Python programmers objected to the new join method, 
		arguing that it should be a method of the list instead, or that it shouldn't move at all but simply stay a part of the old string module (which still has a lot of useful stuff in it). I use the new join method exclusively, 
		but you will see code written either way, and if it really bothers you, you can use the old string.join function instead.

4. The Power Of Introspection	      (compare with reflection)
		This chapter covers one of Python's strengths: introspection. As you know, everything in Python is an object, and introspection is code looking at other modules and functions in memory as objects, 
	getting information about them, and manipulating them. Along the way, you'll define functions with no name, call functions with arguments out of order, and reference functions whose names you don't 
	even know ahead of time.

	4.1. Diving In
		Don't worry if the rest of the code looks intimidating; you'll learn all about it throughout this chapter.
		
			def info(object, spacing=10, collapse=1):   
			    """Print methods and doc strings.
			    Takes module, class, list, dictionary, or string."""
			    methodList = [method for method in dir(object) if callable(getattr(object, method))]
			    processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
			    print "\n".join(["%s %s" %
					      (method.ljust(spacing),
					       processFunc(str(getattr(object, method).__doc__)))
					     for method in methodList])

			if __name__ == "__main__":                 
			    print info.__doc__
				- This module has one function, info. According to its function declaration, it takes three parameters: object, spacing, and collapse. The last two are actually optional parameters, 
				as you'll see shortly.
				- The info function has a multi-line doc string that succinctly describes the function's purpose. Note that no return value is mentioned; this function will be used solely for its effects, 
				rather than its value.
				- Code within the function is indented.
				- The if __name__ trick allows this program do something useful when run by itself, without interfering with its use as a module for other programs. In this case, the program simply 
				prints out the doc string of the info function.
				- if statements use == for comparison, and parentheses are not required.
		
		Example 4.3. Advanced Usage of apihelper.py
			>>> import odbchelper
			>>> info(odbchelper)
			buildConnectionString Build a connection string from a dictionary Returns string.
			>>> info(odbchelper, 30)
			buildConnectionString          Build a connection string from a dictionary Returns string.
			>>> info(odbchelper, 30, 0)
			buildConnectionString          Build a connection string from a dictionary
			    
			Returns string.

	4.2. Using Optional and Named Arguments
			Python allows function arguments to have default values; if the function is called without the argument, the argument gets its default value. Futhermore, arguments can be specified in any order 
		by using named arguments. Stored procedures in SQL Server Transact/SQL can do this, so if you're a SQL Server scripting guru, you can skim this part.
		
			Here is an example of info, a function with two optional arguments:
				def info(object, spacing=10, collapse=1):
			spacing and collapse are optional, because they have default values defined. object is required, because it has no default value. If info is called with only one argument, spacing defaults to 10 
		and collapse defaults to 1. If info is called with two arguments, collapse still defaults to 1.

			Say you want to specify a value for collapse but want to accept the default value for spacing. In most languages, you would be out of luck, because you would need to call the function with three arguments. 
		But in Python, arguments can be specified by name, in any order.
		
		Example 4.4. Valid Calls of info
			info(odbchelper)                    
			info(odbchelper, 12)                
			info(odbchelper, collapse=0)        
			info(spacing=15, object=odbchelper) 
				- With only one argument, spacing gets its default value of 10 and collapse gets its default value of 1.
				- With two arguments, collapse gets its default value of 1.
				- Here you are naming the collapse argument explicitly and specifying its value. spacing still gets its default value of 10.
				- Even required arguments (like object, which has no default value) can be named, and named arguments can appear in any order.
			
			This looks totally whacked until you realize that arguments are simply a dictionary. The “normal” method of calling functions without argument names is actually just a shorthand 
		where Python matches up the values with the argument names in the order they're specified in the function declaration. And most of the time, you'll call functions the “normal” way, 
		but you always have the additional flexibility if you need it.
	
	4.3. Using type, str, dir, and Other Built-In Functions
			Python has a small set of extremely useful built-in functions. All other functions are partitioned off into modules. This was actually a conscious design decision, to keep the core language 
		from getting bloated like other scripting languages (cough cough, Visual Basic).

		4.3.1. The type Function
			The type function returns the datatype of any arbitrary object. The possible types are listed in the types module. This is useful for helper functions that can handle several types of data.

			Example 4.5. Introducing type
				>>> type(1)           
				<type 'int'>
				>>> li = []
				>>> type(li)          
				<type 'list'>
				>>> import odbchelper
				>>> type(odbchelper)  
				<type 'module'>
				>>> import types      
				>>> type(odbchelper) == types.ModuleType
				True
					- type takes anything -- and I mean anything -- and returns its datatype. Integers, strings, lists, dictionaries, tuples, functions, classes, modules, even types are acceptable.
					- type can take a variable and return its datatype.
					- type also works on modules.
					- You can use the constants in the types module to compare types of objects. This is what the info function does, as you'll see shortly.

		4.3.2. The str Function
			The str coerces data into a string. Every datatype can be coerced into a string.

			Example 4.6. Introducing str
				>>> str(1)          
				'1'
				>>> horsemen = ['war', 'pestilence', 'famine']
				>>> horsemen
				['war', 'pestilence', 'famine']
				>>> horsemen.append('Powerbuilder')
				>>> str(horsemen)   
				"['war', 'pestilence', 'famine', 'Powerbuilder']"
				>>> str(odbchelper) 
				"<module 'odbchelper' from 'c:\\docbook\\dip\\py\\odbchelper.py'>"
				>>> str(None)       
				'None'
					- For simple datatypes like integers, you would expect str to work, because almost every language has a function to convert an integer to a string.
					- However, str works on any object of any type. Here it works on a list which you've constructed in bits and pieces.
					- str also works on modules. Note that the string representation of the module includes the pathname of the module on disk, so yours will be different.
					- A subtle but important behavior of str is that it works on None, the Python null value. It returns the string 'None'. You'll use this to your advantage in the info function, as you'll see shortly.

			Example 4.7. Introducing dir
				>>> li = []
				>>> dir(li)           
				['append', 'count', 'extend', 'index', 'insert',
				'pop', 'remove', 'reverse', 'sort']
				>>> d = {}
				>>> dir(d)            
				['clear', 'copy', 'get', 'has_key', 'items', 'keys', 'setdefault', 'update', 'values']
				>>> import odbchelper
				>>> dir(odbchelper)   
				['__builtins__', '__doc__', '__file__', '__name__', 'buildConnectionString']
					- li is a list, so dir(li) returns a list of all the methods of a list. Note that the returned list contains the names of the methods as strings, not the methods themselves.
					- d is a dictionary, so dir(d) returns a list of the names of dictionary methods. At least one of these, keys, should look familiar.
					- This is where it really gets interesting. odbchelper is a module, so dir(odbchelper) returns a list of all kinds of stuff defined in the module, including built-in attributes, 
					like __name__, __doc__, and whatever other attributes and methods you define. In this case, odbchelper has only one user-defined method, the buildConnectionString function 
					described in Chapter 2.
			
			Finally, the callable function takes any object and returns True if the object can be called, or False otherwise. Callable objects include functions, class methods, even classes themselves. 
			(More on classes in the next chapter.)

			       Example 4.8. Introducing callable
					>>> import string
					>>> string.punctuation           
					'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
					>>> string.join                  
					<function join at 00C55A7C>
					>>> callable(string.punctuation) 
					False
					>>> callable(string.join)        
					True
					>>> print string.join.__doc__    
					join(list [,sep]) -> string

					    Return a string composed of the words in list, with
					    intervening occurrences of sep.  The default separator is a
					    single space.

					    (joinfields and join are synonymous)
						- The functions in the string module are deprecated (although many people still use the join function), but the module contains a lot of useful constants like this string.punctuation, 
						which contains all the standard punctuation characters.
						- string.join is a function that joins a list of strings.
						-string.punctuation is not callable; it is a string. (A string does have callable methods, but the string itself is not callable.)
						- string.join is callable; it's a function that takes two arguments.
						- Any callable object may have a doc string. By using the callable function on each of an object's attributes, you can determine which attributes you care about (methods, functions, classes) 
						and which you want to ignore (constants and so on) without knowing anything about the object ahead of time.
							
	       4.3.3. Built-In Functions
				type, str, dir, and all the rest of Python's built-in functions are grouped into a special module called __builtin__. (That's two underscores before and after.) If it helps, 
			you can think of Python automatically executing from __builtin__ import * on startup, which imports all the “built-in” functions into the namespace so you can use them directly.
			
				The advantage of thinking like this is that you can access all the built-in functions and attributes as a group by getting information about the __builtin__ module. And guess what, Python has a function 
			called info. Try it yourself and skim through the list now.

			Example 4.9. Built-in Attributes and Functions
				>>> from apihelper import info
				>>> import __builtin__
				>>> info(__builtin__, 20)
				ArithmeticError      Base class for arithmetic errors.
				AssertionError       Assertion failed.
				AttributeError       Attribute not found.
				EOFError             Read beyond end of file.
				EnvironmentError     Base class for I/O related errors.
				Exception            Common base class for all exceptions.
				FloatingPointError   Floating point operation failed.
				IOError              I/O operation failed.

				[...snip...]
		
	4.4. Getting Object References With getattr
			You already know that Python functions are objects. What you don't know is that you can get a reference to a function without knowing its name until run-time, by using the getattr function.

			Example 4.10. Introducing getattr
				>>> li = ["Larry", "Curly"]
				>>> li.pop                       
				<built-in method pop of list object at 010DF884>
				>>> getattr(li, "pop")           
				<built-in method pop of list object at 010DF884>
				>>> getattr(li, "append")("Moe") 
				>>> li
				["Larry", "Curly", "Moe"]
				>>> getattr({}, "clear")         
				<built-in method clear of dictionary object at 00F113D4>
				>>> getattr((), "pop")           
				Traceback (innermost last):
				  File "<interactive input>", line 1, in ?
				AttributeError: 'tuple' object has no attribute 'pop'
					- This gets a reference to the pop method of the list. Note that this is not calling the pop method; that would be li.pop(). This is the method itself.
					- This also returns a reference to the pop method, but this time, the method name is specified as a string argument to the getattr function. getattr is an incredibly 
					useful built-in function that returns any attribute of any object. In this case, the object is a list, and the attribute is the pop method.
					- In case it hasn't sunk in just how incredibly useful this is, try this: the return value of getattr is the method, which you can then call just as if you had said li.append("Moe") directly. 
					But you didn't call the function directly; you specified the function name as a string instead.
					- getattr also works on dictionaries.
					- In theory, getattr would work on tuples, except that tuples have no methods, so getattr will raise an exception no matter what attribute name you give.

		4.4.1. getattr with Modules
			getattr isn't just for built-in datatypes. It also works on modules.				

			Example 4.11. The getattr Function in apihelper.py
				>>> import odbchelper
				>>> odbchelper.buildConnectionString             
				<function buildConnectionString at 00D18DD4>
				>>> getattr(odbchelper, "buildConnectionString") 
				<function buildConnectionString at 00D18DD4>
				>>> object = odbchelper
				>>> method = "buildConnectionString"
				>>> getattr(object, method)                      
				<function buildConnectionString at 00D18DD4>
				>>> type(getattr(object, method))                
				<type 'function'>
				>>> import types
				>>> type(getattr(object, method)) == types.FunctionType
				True
				>>> callable(getattr(object, method))            
				True

		4.4.2. getattr As a Dispatcher
				A common usage pattern of getattr is as a dispatcher. For example, if you had a program that could output data in a variety of different formats, you could define separate functions 
			for each output format and use a single dispatch function to call the right one.

				For example, let's imagine a program that prints site statistics in HTML, XML, and plain text formats. The choice of output format could be specified on the command line, 
			or stored in a configuration file. A statsout module defines three functions, output_html, output_xml, and output_text. Then the main program defines a single output function, like this:

			Example 4.12. Creating a Dispatcher with getattr

				import statsout

				def output(data, format="text"):                              
				    output_function = getattr(statsout, "output_%s" % format) 
				    return output_function(data)                              
					- The output function takes one required argument, data, and one optional argument, format. If format is not specified, it defaults to text, and you will end up calling the plain text output function.
					- You concatenate the format argument with "output_" to produce a function name, and then go get that function from the statsout module. This allows you to easily extend the program later 
					to support other output formats, without changing this dispatch function. Just add another function to statsout named, for instance, output_pdf, and pass "pdf" as the format into the output function.
					- Now you can simply call the output function in the same way as any other function. The output_function variable is a reference to the appropriate function from the statsout module.
			
			 getattr takes an optional third argument, a default value in case the user passes in a format that doesn't have a corresponding function defined in statsout.

			Example 4.13. getattr Default Values

				import statsout

				def output(data, format="text"):
				    output_function = getattr(statsout, "output_%s" % format, statsout.output_text)
				    return output_function(data) 
						- This function call is guaranteed to work, because you added a third argument to the call to getattr. The third argument is a default value that is returned 
						if the attribute or method specified by the second argument wasn't found.
			
			As you can see, getattr is quite powerful. It is the heart of introspection, and you'll see even more powerful examples of it in later chapters.
		
	4.5. Filtering Lists
		As you know, Python has powerful capabilities for mapping lists into other lists, via list comprehensions (Section 3.6, “Mapping Lists”). This can be combined with a filtering mechanism, 
		where some elements in the list are mapped while others are skipped entirely.
		
		Here is the list filtering syntax:
			[mapping-expression for element in source-list if filter-expression]
		
		The first two thirds are the same; the last part, starting with the if, is the filter expression. A filter expression can be any expression that evaluates true or false (which in Python can be almost anything). 
		Any element for which the filter expression evaluates true will be included in the mapping. All other elements are ignored, so they are never put through the mapping expression and are not included in the output list.

		Example 4.14. Introducing List Filtering
		>>> li = ["a", "mpilgrim", "foo", "b", "c", "b", "d", "d"]
		>>> [elem for elem in li if len(elem) > 1]       
		['mpilgrim', 'foo']
		>>> [elem for elem in li if elem != "b"]         
		['a', 'mpilgrim', 'foo', 'c', 'd', 'd']
		>>> [elem for elem in li if li.count(elem) == 1] 
		['a', 'mpilgrim', 'foo', 'c']
			- count is a list method that returns the number of times a value occurs in a list. You might think that this filter would eliminate duplicates from a list, returning a list containing only one copy 
			of each value in the original list. But it doesn't, because values that appear twice in the original list (in this case, b and d) are excluded completely. There are ways of eliminating duplicates 
			from a list, but filtering is not the solution.
		
		Let's get back to this line from apihelper.py:
			methodList = [method for method in dir(object) if callable(getattr(object, method))]
			
			This looks complicated, and it is complicated, but the basic structure is the same. The whole filter expression returns a list, which is assigned to the methodList variable. 
		The first half of the expression is the list mapping part. The mapping expression is an identity expression, which it returns the value of each element. dir(object) returns a list 
		of object's attributes and methods -- that's the list you're mapping. So the only new part is the filter expression after the if.
			So this expression takes an object (named object). Then it gets a list of the names of the object's attributes, methods, functions, and a few other things. Then it filters that list to weed out all the stuff 
		that you don't care about. You do the weeding out by taking the name of each attribute/method/function and getting a reference to the real thing, via the getattr function. Then you check to see if that object 
		is callable, which will be any methods and functions, both built-in (like the pop method of a list) and user-defined (like the buildConnectionString function of the odbchelper module). You don't care about 
		other attributes, like the __name__ attribute that's built in to every module.

	4.6. The Peculiar Nature of and and or
		4.6.1. Using the and-or Trick
		In Python, and and or perform boolean logic as you would expect, but they do not return boolean values; instead, they return one of the actual values they are comparing.

		Example 4.15. Introducing and
		>>> 'a' and 'b'         
		'b'
		>>> '' and 'b'          
		''
		>>> 'a' and 'b' and 'c' 
		'c'
			- When using and, values are evaluated in a boolean context from left to right. 0, '', [], (), {}, and None are false in a boolean context; everything else is true. Well, almost everything. 
			By default, instances of classes are true in a boolean context, but you can define special methods in your class to make an instance evaluate to false. You'll learn all about classes and 
			special methods in Chapter 5. If all values are true in a boolean context, and returns the last value. In this case, and evaluates 'a', which is true, then 'b', which is true, and returns 'b'.
			- If any value is false in a boolean context, and returns the first false value. In this case, '' is the first false value.
			- All values are true, so and returns the last value, 'c'.
		
		Example 4.16. Introducing or
		>>> 'a' or 'b'          
		'a'
		>>> '' or 'b'           
		'b'
		>>> '' or [] or {}      
		{}
		>>> def sidefx():
		...     print "in sidefx()"
		...     return 1
		>>> 'a' or sidefx()     
		'a'
			- When using or, values are evaluated in a boolean context from left to right, just like and. If any value is true, or returns that value immediately. In this case, 'a' is the first true value.
			- or evaluates '', which is false, then 'b', which is true, and returns 'b'.
			- If all values are false, or returns the last value. or evaluates '', which is false, then [], which is false, then {}, which is false, and returns {}.
			- Note that or evaluates values only until it finds one that is true in a boolean context, and then it ignores the rest. This distinction is important if some values can have side effects. Here, the function sidefx is never called, because or evaluates 'a', which is true, and returns 'a' immediately.
		
		返回的值自身的true或false即为表达式的true或false。
	
	4.6.1. Using the and-or Trick

		Example 4.17. Introducing the and-or Trick
		>>> a = "first"
		>>> b = "second"
		>>> 1 and a or b 
		'first'
		>>> 0 and a or b 
		'second'
			- This syntax looks similar to the bool ? a : b expression in C(ps: they are different). The entire expression is evaluated from left to right, so the and is evaluated first. 1 and 'first' evalutes to 'first', then 'first' or 'second' evalutes to 'first'.
			- 0 and 'first' evalutes to False, and then 0 or 'second' evaluates to 'second'.	 
		
		Example 4.18. When the and-or Trick Fails
		>>> a = ""
		>>> b = "second"
		>>> 1 and a or b         
		'second'

		Example 4.19. Using the and-or Trick Safely
		>>> a = ""
		>>> b = "second"
		>>> (1 and [a] or [b])[0] 
		''
			- Since [a] is a non-empty list, it is never false. Even if a is 0 or '' or some other false value, the list [a] is true because it has one element.
		
		By now, this trick may seem like more trouble than it's worth. You could, after all, accomplish the same thing with an if statement, so why go through all this fuss? Well, in many cases, 
		you are choosing between two constant values, so you can use the simpler syntax and not worry, because you know that the a value will always be true. And even if you need to use the 
		more complicated safe form, there are good reasons to do so. For example, there are some cases in Python where if statements are not allowed, such as in lambda functions.
	
	4.7. Using lambda Functions
		4.7.1. Real-World lambda Functions
			Python supports an interesting syntax that lets you define one-line mini-functions on the fly. Borrowed from Lisp, these so-called lambda functions can be used anywhere a function is required.

			Example 4.20. Introducing lambda Functions
			>>> def f(x):
			...     return x*2
			...     
			>>> f(3)
			6
			>>> g = lambda x: x*2  
			>>> g(3)
			6
			>>> (lambda x: x*2)(3) 
			6
				- This is a lambda function that accomplishes the same thing as the normal function above it. Note the abbreviated syntax here: there are no parentheses around the argument list, 
				and the return keyword is missing (it is implied, since the entire function can only be one expression). Also, the function has no name, but it can be called through the variable it is assigned to.
				- You can use a lambda function without even assigning it to a variable. This may not be the most useful thing in the world, but it just goes to show that a lambda is just an in-line function.
			
				To generalize, a lambda function is a function that takes any number of arguments (including optional arguments) and returns the value of a single expression. lambda functions can not contain commands, 
			and they can not contain more than one expression. Don't try to squeeze too much into a lambda function; if you need something more complex, define a normal function instead and make it as long 
			as you want.
				lambda functions are a matter of style. Using them is never required; anywhere you could use them, you could define a separate normal function and use that instead. I use them in places where I want to 
			encapsulate specific, non-reusable code without littering my code with a lot of little one-line functions.

		4.7.1. Real-World lambda Functions
			Here are the lambda functions in apihelper.py:
				processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
			Notice that this uses the simple form of the and-or trick, which is okay, because a lambda function is always true in a boolean context. (That doesn't mean that a lambda function can't return a false value. 
			The function is always true; its return value could be anything.)

			Example 4.21. split With No Arguments
			>>> s = "this   is\na\ttest"  
			>>> print s
			this   is
			a   test
			>>> print s.split()           
			['this', 'is', 'a', 'test']
			>>> print " ".join(s.split()) 
			'this is a test'
				- This is a multiline string, defined by escape characters instead of triple quotes. \n is a carriage return, and \t is a tab character.
				- split without any arguments splits on whitespace. So three spaces, a carriage return, and a tab character are all the same.
				- You can normalize whitespace by splitting a string with split and then rejoining it with join, using a single space as a delimiter. This is what the info function does to collapse multi-line 
				doc strings into a single line.
		
		why this?
			To do this in a less robust language, like Visual Basic, you would probably create a function that took a string and a collapse argument and used an if statement to decide whether to collapse the whitespace or not, 
		then returned the appropriate value. This would be inefficient, because the function would need to handle every possible case. Every time you called it, it would need to decide whether to collapse whitespace 
		before it could give you what you wanted. In Python, you can take that decision logic out of the function and define a lambda function that is custom-tailored to give you exactly (and only) what you want. 
		This is more efficient, more elegant, and less prone to those nasty oh-I-thought-those-arguments-were-reversed kinds of errors.

	4.8. Putting It All Together

		The next piece of the puzzle is the use of str around the doc string. As you may recall, str is a built-in function that coerces data into a string. But a doc string is always a string, so why bother with the str function? 
		The answer is that not every function has a doc string, and if it doesn't, its __doc__ attribute is None.

		Example 4.23. Why Use str on a doc string?
		>>> >>> def foo(): print 2
		>>> >>> foo()
		2
		>>> >>> foo.__doc__     
		>>> foo.__doc__ == None 
		True
		>>> str(foo.__doc__)    
		'None'
			- You can easily define a function that has no doc string, so its __doc__ attribute is None. Confusingly, if you evaluate the __doc__ attribute directly, the Python IDE prints nothing at all, which makes sense 
			if you think about it, but is still unhelpful.
			- You can verify that the value of the __doc__ attribute is actually None by comparing it directly.
			- The str function takes the null value and returns a string representation of it, 'None'.

		In SQL, you must use IS NULL instead of = NULL to compare a null value. In Python, you can use either == None or is None, but is None is faster.

		Stepping back even further, you see that you're using string formatting again to concatenate the return value of processFunc with the return value of method's ljust method. This is a new string method that 
		you haven't seen before.

		Example 4.24. Introducing ljust
		>>> s = 'buildConnectionString'
		>>> s.ljust(30) 
		'buildConnectionString         '
		>>> s.ljust(20) 
		'buildConnectionString'
			- ljust pads the string with spaces to the given length. This is what the info function uses to make two columns of output and line up all the doc strings in the second column.
			- If the given length is smaller than the length of the string, ljust will simply return the string unchanged. It never truncates the string.

		Example 4.25. Printing a List
		>>> li = ['a', 'b', 'c']
		>>> print "\n".join(li) 
		a
		b
		c
			This is also a useful debugging trick when you're working with lists. And in Python, you're always working with lists.
		That's the last piece of the puzzle. You should now understand this code.

		    print "\n".join(["%s %s" %
				      (method.ljust(spacing),
				       processFunc(str(getattr(object, method).__doc__)))
				     for method in methodList])

5. Objects and Object-Orientation

	5.1. Diving In
		Here is a complete, working Python program. Read the doc strings of the module, the classes, and the functions to get an overview of what this program does and how it works. As usual, 
		don't worry about the stuff you don't understand; that's what the rest of the chapter is for.

		Example 5.1. fileinfo.py
		If you have not already done so, you can download this and other examples used in this book.

		"""Framework for getting filetype-specific metadata.

		Instantiate appropriate class with filename.  Returned object acts like a
		dictionary, with key-value pairs for each piece of metadata.
		    import fileinfo
		    info = fileinfo.MP3FileInfo("/music/ap/mahadeva.mp3")
		    print "\\n".join(["%s=%s" % (k, v) for k, v in info.items()])

		Or use listDirectory function to get info on all files in a directory.
		    for info in fileinfo.listDirectory("/music/ap/", [".mp3"]):
			...

		Framework can be extended by adding classes for particular file types, e.g.
		HTMLFileInfo, MPGFileInfo, DOCFileInfo.  Each class is completely responsible for
		parsing its files appropriately; see MP3FileInfo for example.
		"""
		import os
		import sys
		from UserDict import UserDict

		def stripnulls(data):
		    "strip whitespace and nulls"
		    return data.replace("\00", "").strip()

		class FileInfo(UserDict):
		    "store file metadata"
		    def __init__(self, filename=None):
			UserDict.__init__(self)
			self["name"] = filename

		class MP3FileInfo(FileInfo):
		    "store ID3v1.0 MP3 tags"
		    tagDataMap = {"title"   : (  3,  33, stripnulls),
				  "artist"  : ( 33,  63, stripnulls),
				  "album"   : ( 63,  93, stripnulls),
				  "year"    : ( 93,  97, stripnulls),
				  "comment" : ( 97, 126, stripnulls),
				  "genre"   : (127, 128, ord)}

		    def __parse(self, filename):
			"parse ID3v1.0 tags from MP3 file"
			self.clear()
			try:                               
			    fsock = open(filename, "rb", 0)
			    try:                           
				fsock.seek(-128, 2)        
				tagdata = fsock.read(128)  
			    finally:                       
				fsock.close()              
			    if tagdata[:3] == "TAG":
				for tag, (start, end, parseFunc) in self.tagDataMap.items():
				    self[tag] = parseFunc(tagdata[start:end])               
			except IOError:                    
			    pass                           

		    def __setitem__(self, key, item):
			if key == "name" and item:
			    self.__parse(item)
			FileInfo.__setitem__(self, key, item)

		def listDirectory(directory, fileExtList):                                        
		    "get list of file info objects for files of particular extensions"
		    fileList = [os.path.normcase(f)
				for f in os.listdir(directory)]           
		    fileList = [os.path.join(directory, f) 
			       for f in fileList
				if os.path.splitext(f)[1] in fileExtList] 
		    def getFileInfoClass(filename, module=sys.modules[FileInfo.__module__]):      
			"get file info class from filename extension"                             
			subclass = "%sFileInfo" % os.path.splitext(filename)[1].upper()[1:]       
			return hasattr(module, subclass) and getattr(module, subclass) or FileInfo
		    return [getFileInfoClass(f)(f) for f in fileList]                             

		if __name__ == "__main__":
		    for info in listDirectory("/music/_singles/", [".mp3"]): 
			print "\n".join(["%s=%s" % (k, v) for k, v in info.items()])
			print

			- This program's output depends on the files on your hard drive. To get meaningful output, you'll need to change the directory path to point to a directory of MP3 files on your own machine.
		
		This is the output I got on my machine. Your output will be different, unless, by some startling coincidence, you share my exact taste in music.

		album=
		artist=Ghost in the Machine
		title=A Time Long Forgotten (Concept
		genre=31
		name=/music/_singles/a_time_long_forgotten_con.mp3
		year=1999
		comment=http://mp3.com/ghostmachine

		album=Rave Mix
		artist=***DJ MARY-JANE***
		title=HELLRAISER****Trance from Hell
		genre=31
		name=/music/_singles/hellraiser.mp3
		year=2000
		comment=http://mp3.com/DJMARYJANE

		album=Rave Mix
		artist=***DJ MARY-JANE***
		title=KAIRO****THE BEST GOA
		genre=31
		name=/music/_singles/kairo.mp3
		year=2000
		comment=http://mp3.com/DJMARYJANE

		album=Journeys
		artist=Masters of Balance
		title=Long Way Home
		genre=31
		name=/music/_singles/long_way_home1.mp3
		year=2000
		comment=http://mp3.com/MastersofBalan

		album=
		artist=The Cynic Project
		title=Sidewinder
		genre=18
		name=/music/_singles/sidewinder.mp3
		year=2000
		comment=http://mp3.com/cynicproject

		album=Digitosis@128k
		artist=VXpanded
		title=Spinning
		genre=255
		name=/music/_singles/spinning.mp3
		year=2000
		comment=http://mp3.com/artists/95/vxp

	5.2. Importing Modules Using from module import
		Python has two ways of importing modules. Both are useful, and you should know when to use each. One way, import module, you've already seen in Section 2.4, “Everything Is an Object”. 
		The other way accomplishes the same thing, but it has subtle and important differences.

		Here is the basic from module import syntax:
			from UserDict import UserDict
		This is similar to the import module syntax that you know and love, but with an important difference: the attributes and methods of the imported module types are imported directly into the local namespace, 
		so they are available directly, without qualification by module name. You can import individual items or use from module import * to import everything.
			- from module import * in Python is like import module.* in Java; import module in Python is like import module in Java.
		
		Example 5.2. import module vs. from module import
		>>> import types
		>>> types.FunctionType             
		<type 'function'>
		>>> FunctionType                   
		Traceback (innermost last):
		  File "<interactive input>", line 1, in ?
		NameError: There is no variable named 'FunctionType'
		>>> from types import FunctionType 
		>>> FunctionType                   
		<type 'function'>
			- The types module contains no methods; it just has attributes for each Python object type. Note that the attribute, FunctionType, must be qualified by the module name, types.
			- FunctionType by itself has not been defined in this namespace; it exists only in the context of types.
			- This syntax imports the attribute FunctionType from the types module directly into the local namespace.
			- Now FunctionType can be accessed directly, without reference to types.
		
		When should you use from module import?
			- If you will be accessing attributes and methods often and don't want to type the module name over and over, use from module import.
			- If you want to selectively import some attributes and methods but not others, use from module import.
			- If the module contains attributes or functions with the same name as ones in your module, you must use import module to avoid name conflicts.
			- Other than that, it's just a matter of style, and you will see Python code written both ways.
		
		Use from module import * sparingly, because it makes it difficult to determine where a particular function or attribute came from, and that makes debugging and refactoring more difficult.

	5.3. Defining Classes
	
		Python is fully object-oriented: you can define your own classes, inherit from your own or built-in classes, and instantiate the classes you've defined.
		
		Defining a class in Python is simple. As with functions, there is no separate interface definition. Just define the class and start coding. A Python class starts with the reserved word class, followed by the class name. 
		Technically, that's all that's required, since a class doesn't need to inherit from any other class.

		Example 5.3. The Simplest Python Class

		class Loaf: 
		    pass     
			- The name of this class is Loaf, and it doesn't inherit from any other class. Class names are usually capitalized, EachWordLikeThis, but this is only a convention, not a requirement.
			- This class doesn't define any methods or attributes, but syntactically, there needs to be something in the definition, so you use pass. This is a Python reserved word that just means “move along, nothing to see here”. It's a statement that does nothing, and it's a good placeholder when you're stubbing out functions or classes.
			- You probably guessed this, but everything in a class is indented, just like the code within a function, if statement, for loop, and so forth. The first thing not indented is not in the class.

		Of course, realistically, most classes will be inherited from other classes, and they will define their own class methods and attributes. But as you've just seen, there is nothing that a class absolutely must have, 
		other than a name. In particular, C++ programmers may find it odd that Python classes don't have explicit constructors and destructors. Python classes do have something similar to a constructor: the __init__ method.

		Example 5.4. Defining the FileInfo Class

		from UserDict import UserDict

		class FileInfo(UserDict): 
			- In Python, the ancestor of a class is simply listed in parentheses immediately after the class name. So the FileInfo class is inherited from the UserDict class (which was imported from the UserDict module). 
			UserDict is a class that acts like a dictionary, allowing you to essentially subclass the dictionary datatype and add your own behavior. (There are similar classes UserList and UserString which allow you 
			to subclass lists and strings.) There is a bit of black magic behind this, which you will demystify later in this chapter when you explore the UserDict class in more depth.

		In Python, the ancestor of a class is simply listed in parentheses immediately after the class name. There is no special keyword like extends in Java.
		
		Python supports multiple inheritance. In the parentheses following the class name, you can list as many ancestor classes as you like, separated by commas.

		5.3.1. Initializing and Coding Classes
			This example shows the initialization of the FileInfo class using the __init__ method.

			Example 5.5. Initializing the FileInfo Class
			class FileInfo(UserDict):
			    "store file metadata"              
			    def __init__(self, filename=None):   

				- Classes can (and should) have doc strings too, just like modules and functions.
				- __init__ is called immediately after an instance of the class is created. It would be tempting but incorrect to call this the constructor of the class. It's tempting, because it looks like 
				a constructor (by convention, __init__ is the first method defined for the class), acts like one (it's the first piece of code executed in a newly created instance of the class), and even sounds like 
				one (“init” certainly suggests a constructor-ish nature). Incorrect, because the object has already been constructed by the time __init__ is called, and you already have a valid reference to the 
				new instance of the class. But __init__ is the closest thing you're going to get to a constructor in Python, and it fills much the same role.
				- The first argument of every class method, including __init__, is always a reference to the current instance of the class. By convention, this argument is always named self. In the __init__ method, 
				self refers to the newly created object; in other class methods, it refers to the instance whose method was called. Although you need to specify self explicitly when defining the method, you do not 
				specify it when calling the method; Python will add it for you automatically.
				- __init__ methods can take any number of arguments, and just like functions, the arguments can be defined with default values, making them optional to the caller. In this case, filename has a 
				default value of None, which is the Python null value.

			Example 5.6. Coding the FileInfo Class
			class FileInfo(UserDict):
			    "store file metadata"
			    def __init__(self, filename=None):
				UserDict.__init__(self)        
				self["name"] = filename        							       
					- Some pseudo-object-oriented languages like Powerbuilder have a concept of “extending” constructors and other events, where the ancestor's method is called automatically before 
					the descendant's method is executed. Python does not do this; you must always explicitly call the appropriate method in the ancestor class.
					- I told you that this class acts like a dictionary, and here is the first sign of it. You're assigning the argument filename as the value of this object's name key.
					- Note that the __init__ method never returns a value.
		
		实例化：
			instanceName = YourClassName();
			
		5.3.2. Knowing When to Use self and __init__

			When defining your class methods, you must explicitly list self as the first argument for each method, including __init__. When you call a method of an ancestor class from within your class, 
		you must include the self argument. But when you call your class method from outside, you do not specify anything for the self argument; you skip it entirely, and Python automatically adds 
		the instance reference for you. I am aware that this is confusing at first; it's not really inconsistent, but it may appear inconsistent because it relies on a distinction (between bound and unbound methods) 
		that you don't know about yet.

		__init__ methods are optional, but when you define one, you must remember to explicitly call the ancestor's __init__ method (if it defines one). This is more generally true: whenever a descendant wants to 
		extend the behavior of the ancestor, the descendant method must explicitly call the ancestor method at the proper time, with the proper arguments.

	5.4. Instantiating Classes -tip-
		Instantiating classes in Python is straightforward. To instantiate a class, simply call the class as if it were a function, passing the arguments that the __init__ method defines. The return value will be 
		the newly created object.

		Example 5.7. Creating a FileInfo Instance
			>>> class FileInfo(UserDict):
					"""
					doc
					"""
					def __init__(self,fileName=None):
						UserDict.__init__(self)
						self["name"]=fileName

			>>> f=FileInfo("abc")
			>>> f.__class__
			<class __main__.FileInfo at 0x02802DF8>
			>>> f.__doc__
			'\n    doc\n    '
			>>> f
			{'name': 'abc'}
				- You are creating an instance of the FileInfo class (defined in the fileinfo module) and assigning the newly created instance to the variable f. You are passing one parameter, 
				/music/_singles/kairo.mp3, which will end up as the filename argument in FileInfo's __init__ method.
				- Every class instance has a built-in attribute, __class__, which is the object's class. (Note that the representation of this includes the physical address of the instance on my machine; 
				your representation will be different.) Java programmers may be familiar with the Class class, which contains methods like getName and getSuperclass to get metadata information about 
				an object. In Python, this kind of metadata is available directly on the object itself through attributes like __class__, __name__, and __bases__.
				- You can access the instance's doc string just as with a function or a module. All instances of a class share the same doc string.
				- Remember when the __init__ method assigned its filename argument to self["name"]? Well, here's the result. The arguments you pass when you create the class instance get sent right along 
				to the __init__ method (along with the object reference, self, which Python adds for free).
		
		In Python, simply call a class as if it were a function to create a new instance of the class. There is no explicit new operator like C++ or Java. (ps:you need parentheses("()") to execute 
		method or get instance from class)

		5.4.1. Garbage Collection
			If creating new instances is easy, destroying them is even easier. In general, there is no need to explicitly free instances, because they are freed automatically when the variables assigned to them 
			go out of scope. Memory leaks are rare in Python.

			Example 5.8. Trying to Implement a Memory Leak
			>>> def leakmem():
			...     f = fileinfo.FileInfo('/music/_singles/kairo.mp3') 
			...     
			>>> for i in range(100):
			...     leakmem()                                          
				- Every time the leakmem function is called, you are creating an instance of FileInfo and assigning it to the variable f, which is a local variable within the function. Then the function ends 
				without ever freeing f, so you would expect a memory leak, but you would be wrong. When the function ends, the local variable f goes out of scope. At this point, there are no longer any references 
				to the newly created instance of FileInfo (since you never assigned it to anything other than f), so Python destroys the instance for us.
				- No matter how many times you call the leakmem function, it will never leak memory, because every time, Python will destroy the newly created FileInfo class before returning from leakmem.

			The technical term for this form of garbage collection is “reference counting”. Python keeps a list of references to every instance created. In the above example, there was only one 
			reference to the FileInfo instance: the local variable f. When the function ends, the variable f goes out of scope, so the reference count drops to 0, and Python destroys the instance automatically.

			In previous versions of Python, there were situations where reference counting failed, and Python couldn't clean up after you. If you created two instances that referenced each other (for instance, 
			a doubly-linked list, where each node has a pointer to the previous and next node in the list), neither instance would ever be destroyed automatically because Python (correctly) believed that there is 
			always a reference to each instance. Python 2.0 has an additional form of garbage collection called “mark-and-sweep” which is smart enough to notice this virtual gridlock and clean up circular references 
			correctly.
			(PS: refer to java's GC)
			ref for more detail: http://www.brpreiss.com/books/opus7/html/page425.html
					In order to distinguish the live objects from garbage, we record the state of an object in each object. That is, we add a special bool field to each object called, say, marked. By default, 
				all objects are unmarked when they are created. Thus, the marked field is initially False.
					The main disadvantage of the mark-and-sweep approach is the fact that that normal program execution is suspended while the garbage collection algorithm runs. In particular, this can be 
				a problem in a program that interacts with a human user or that must satisfy real-time execution constraints. For example, an interactive application that uses mark-and-sweep garbage collection 
				becomes unresponsive periodically.

				The Fragmentation Problem 内存碎片问题(上面的标记-清除算法会有此问题，引出下面的停止-拷贝回收算法)

				Stop-and-Copy Garbage Collection
					The section describes a garbage collection approach that collects garbage and defragments the heap called stop-and-copy  . When using the stop-and-copy garbage collection algorithm, 
				the heap is divided into two separate regions. At any point in time, all dynamically allocated object instances reside in only one of the two regions--the active region. The other, inactive region is 
				unoccupied.
					When the memory in the active region is exhausted, the program is suspended and the garbage-collection algorithm is invoked. The stop-and-copy algorithm copies all of the live objects 
				from the active region to the inactive region. As each object is copied, all references contained in that object are updated to reflect the new locations of the referenced objects.
					After the copying is completed, the active and inactive regions exchange their roles. Since the stop-and-copy algorithm copies only the live objects, the garbage objects are left behind. 
				In effect, the storage occupied by the garbage is reclaimed all at once when the active region becomes inactive.
					As the stop-and-copy algorithm copies the live objects from the active region to the inactive region, it stores the objects in contiguous memory locations. Thus, the stop-and-copy algorithm 
				automatically defragments the heap. This is the main advantage of the stop-and-copy approach over the mark-and-sweep algorithm described in the preceding section.
					The costs of the stop-and-copy algorithm are twofold: First, the algorithm requires that all live objects be copied every time garbage collection is invoked. If an application program has a 
				large memory footprint, the time required to copy all objects can be quite significant. A second cost associated with stop-and-copy is the fact that it requires twice as much memory as the program 
				actually uses. When garbage collection is finished, at least half of the memory space is unused.

				Mark-and-Compact Garbage Collection
					The mark-and-sweep algorithm described in Section  has the unfortunate tendency to fragment the heap. The stop-and-copy algorithm described in Section  avoids fragmentation at the expense 
				of doubling the size of the heap. This section describes the mark-and-compact   approach to garbage collection which eliminates fragmentation without the space penalty of stop-and-copy.
					The mark-and-compact algorithm consists of two phases: In the first phase, it finds and marks all live objects. The first phase is called the mark phase. In the second phase, the garbage collection 
				algorithm compacts the heap by moving all the live objects into contiguous memory locations. The second phase is called the compaction  phase.

	5.5. Exploring UserDict: A Wrapper Class
			As you've seen, FileInfo is a class that acts like a dictionary. To explore this further, let's look at the UserDict class in the UserDict module, which is the ancestor of the FileInfo class. 
		This is nothing special; the class is written in Python and stored in a .py file, just like any other Python code. In particular, it's stored in the lib directory in your Python installation.

		Example 5.9. Defining the UserDict Class

		class UserDict:                                
		    def __init__(self, dict=None):             
			self.data = {}                         
			if dict is not None: self.update(dict)  
				- Note that UserDict is a base class, not inherited from any other class.
				- This is the __init__ method that you overrode in the FileInfo class. Note that the argument list in this ancestor class is different than the descendant. That's okay; each subclass can have its own set 
				of arguments, as long as it calls the ancestor with the correct arguments. Here the ancestor class has a way to define initial values (by passing a dictionary in the dict argument) which the FileInfo does 
				not use.
				- Python supports data attributes (called “instance variables” in Java and Powerbuilder, and “member variables” in C++). Data attributes are pieces of data held by a specific instance of a class. 
				In this case, each instance of UserDict will have a data attribute data. To reference this attribute from code outside the class, you qualify it with the instance name, instance.data, in the same way that 
				you qualify a function with its module name. To reference a data attribute from within the class, you use self as the qualifier. By convention, all data attributes are initialized to reasonable values in the 
				__init__ method. However, this is not required, since data attributes, like local variables, spring into existence when they are first assigned a value.
				- The update method is a dictionary duplicator: it copies all the keys and values from one dictionary to another. This does not clear the target dictionary first; if the target dictionary already has some 
				keys, the ones from the source dictionary will be overwritten, but others will be left untouched. Think of update as a merge function, not a copy function.
				- This is a syntax you may not have seen before (I haven't used it in the examples in this book). It's an if statement, but instead of having an indented block starting on the next line, there is just a 
				single statement on the same line, after the colon. This is perfectly legal syntax, which is just a shortcut you can use when you have only one statement in a block. (It's like specifying a single statement 
				without braces in C++.) You can use this syntax, or you can have indented code on subsequent lines, but you can't do both for the same block.
							
		Always assign an initial value to all of an instance's data attributes in the __init__ method. It will save you hours of debugging later, tracking down AttributeError exceptions because you're referencing 
		uninitialized (and therefore non-existent) attributes.
		
		Example 5.10. UserDict Normal Methods

			def clear(self): self.data.clear()          
			def copy(self):                             
				if self.__class__ is UserDict:          
				    return UserDict(self.data)         
				import copy                             
				return copy.copy(self)                 
			def keys(self): return self.data.keys()     
			def items(self): return self.data.items()  
			def values(self): return self.data.values()
				- The copy method of a real dictionary returns a new dictionary that is an exact duplicate of the original (all the same key-value pairs). But UserDict can't simply redirect to self.data.copy, 
				because that method returns a real dictionary, and what you want is to return a new instance that is the same class as self.
				- You use the __class__ attribute to see if self is a UserDict; if so, you're golden, because you know how to copy a UserDict: just create a new UserDict and give it the real dictionary that 
				you've squirreled away in self.data. Then you immediately return the new UserDict you don't even get to the import copy on the next line.
				- If self.__class__ is not UserDict, then self must be some subclass of UserDict (like maybe FileInfo), in which case life gets trickier. UserDict doesn't know how to make an exact copy of 
				one of its descendants; there could, for instance, be other data attributes defined in the subclass, so you would need to iterate through them and make sure to copy all of them. Luckily, Python 
				comes with a module to do exactly this, and it's called copy. I won't go into the details here (though it's a wicked cool module, if you're ever inclined to dive into it on your own). Suffice it to say 
				that copy can copy arbitrary Python objects, and that's how you're using it here.
				- The rest of the methods are straightforward, redirecting the calls to the built-in methods on self.data.
		
			In versions of Python prior to 2.2, you could not directly subclass built-in datatypes like strings, lists, and dictionaries. To compensate for this, Python comes with wrapper classes that mimic the behavior 
		of these built-in datatypes: UserString, UserList, and UserDict. Using a combination of normal and special methods, the UserDict class does an excellent imitation of a dictionary. In Python 2.2 and later, 
		you can inherit classes directly from built-in datatypes like dict. An example of this is given in the examples that come with this book, in fileinfo_fromdict.py.

		Example 5.11. Inheriting Directly from Built-In Datatype dict

			class FileInfo(dict):                  
			    "store file metadata"
			    def __init__(self, filename=None): 
				self["name"] = filename
					- The first difference is that you don't need to import the UserDict module, since dict is a built-in datatype and is always available. The second is that you are inheriting from dict directly, 
					instead of from UserDict.UserDict.
					- The third difference is subtle but important. Because of the way UserDict works internally, it requires you to manually call its __init__ method to properly initialize its internal data structures. 
					dict does not work like this; it is not a wrapper, and it requires no explicit initialization.

	5.6. Special Class Methods
		In addition to normal class methods, there are a number of special methods that Python classes can define. Instead of being called directly by your code (like normal methods), 
		special methods are called for you by Python in particular circumstances or when specific syntax is used.

		As you saw in the previous section, normal methods go a long way towards wrapping a dictionary in a class. But normal methods alone are not enough, because there are a lot of things you can do with 
		dictionaries besides call methods on them. For starters, you can get and set items with a syntax that doesn't include explicitly invoking methods. This is where special class methods come in: they provide 
		a way to map non-method-calling syntax into method calls. 特殊类方法映射到非方法调用的操作，比如符合某种格式的赋值(程序代码并没有显式调用赋值方法)方式。

		5.6.1. Getting and Setting Items

			Example 5.12. The __getitem__ Special Method
			    def __getitem__(self, key): return self.data[key]
			>>> f = fileinfo.FileInfo("/music/_singles/kairo.mp3")
			>>> f
			{'name':'/music/_singles/kairo.mp3'}
			>>> f.__getitem__("name") 
			'/music/_singles/kairo.mp3'
			>>> f["name"]             
			'/music/_singles/kairo.mp3'
				- The __getitem__ special method looks simple enough. Like the normal methods clear, keys, and values, it just redirects to the dictionary to return its value. But how does it get called? Well, 
				you can call __getitem__ directly, but in practice you wouldn't actually do that; I'm just doing it here to show you how it works. The right way to use __getitem__ is to get Python to call it for you.
				- This looks just like the syntax you would use to get a dictionary value, and in fact it returns the value you would expect. But here's the missing link: under the covers, Python has converted this 
				syntax to the method call f.__getitem__("name"). That's why __getitem__ is a special class method; not only can you call it yourself, you can get Python to call it for you by using the right syntax.
			
			Example 5.13. The __setitem__ Special Method
				 def __setitem__(self, key, item): self.data[key] = item
			>>> f
			{'name':'/music/_singles/kairo.mp3'}
			>>> f.__setitem__("genre", 31) 
			>>> f
			{'name':'/music/_singles/kairo.mp3', 'genre':31}
			>>> f["genre"] = 32            
			>>> f
			{'name':'/music/_singles/kairo.mp3', 'genre':32}
				- Like the __getitem__ method, __setitem__ simply redirects to the real dictionary self.data to do its work. And like __getitem__, you wouldn't ordinarily call it directly like this; Python calls 
				__setitem__ for you when you use the right syntax.
				- This looks like regular dictionary syntax, except of course that f is really a class that's trying very hard to masquerade as a dictionary, and __setitem__ is an essential part of that masquerade. 
				This line of code actually calls f.__setitem__("genre", 32) under the covers.
			
			__setitem__ is a special class method because it gets called for you, but it's still a class method. Just as easily as the __setitem__ method was defined in UserDict, you can redefine it in the descendant 
			class to override the ancestor method. This allows you to define classes that act like dictionaries in some ways but define their own behavior above and beyond the built-in dictionary.

			This concept is the basis of the entire framework you're studying in this chapter. Each file type can have a handler class that knows how to get metadata from a particular type of file. Once some attributes 
			(like the file's name and location) are known, the handler class knows how to derive other attributes automatically. This is done by overriding the __setitem__ method, checking for particular keys, and adding 
			additional processing when they are found. 
			(PS:重写父类方法，实现自定义的行为，满足需要。比如file类型，只要提供文件地址，就可以获得文件的其他信息，就是因为file类型重写了__setitem__方法。)

			Example 5.14. Overriding __setitem__ in MP3FileInfo
			def __setitem__(self, key, item):         
				if key == "name" and item:            
				    self.__parse(item)                
				FileInfo.__setitem__(self, key, item) 
					- Notice that this __setitem__ method is defined exactly the same way as the ancestor method. This is important, since Python will be calling the method for you, and it expects it to be defined 
					with a certain number of arguments. (Technically speaking, the names of the arguments don't matter; only the number of arguments is important.)
					- Here's the crux of the entire MP3FileInfo class: if you're assigning a value to the name key, you want to do something extra.
					- The extra processing you do for names is encapsulated in the __parse method. This is another class method defined in MP3FileInfo, and when you call it, you qualify it with self. Just calling 
					__parse would look for a normal function defined outside the class, which is not what you want. Calling self.__parse will look for a class method defined within the class. This isn't anything new; 
					you reference data attributes the same way.
					- After doing this extra processing, you want to call the ancestor method. Remember that this is never done for you in Python; you must do it manually. Note that you're calling the immediate 
					ancestor, FileInfo, even though it doesn't have a __setitem__ method. That's okay, because Python will walk up the ancestor tree until it finds a class with the method you're calling, so this line 
					of code will eventually find and call the __setitem__ defined in UserDict.

			When accessing data attributes within a class, you need to qualify the attribute name: self.attribute. When calling other methods within a class, you need to qualify the method name: self.method.

	5.7. Advanced Special Class Methods
		Python has more special methods than just __getitem__ and __setitem__. Some of them let you emulate functionality that you may not even know about.

		This example shows some of the other special methods in UserDict.

		Example 5.16. More Special Methods in UserDict
		    def __repr__(self): return repr(self.data)     
		    def __cmp__(self, dict):                       
			if isinstance(dict, UserDict):            
			    return cmp(self.data, dict.data)      
			else:                                     
			    return cmp(self.data, dict)           
		    def __len__(self): return len(self.data)       
		    def __delitem__(self, key): del self.data[key] 
			- __repr__ is a special method that is called when you call repr(instance). The repr function is a built-in function that returns a string representation of an object. It works on any object, not 
			just class instances. You're already intimately familiar with repr and you don't even know it. In the interactive window, when you type just a variable name and press the ENTER key, Python uses 
			repr to display the variable's value. Go create a dictionary d with some data and then print repr(d) to see for yourself.
			- __cmp__ is called when you compare class instances. In general, you can compare any two Python objects, not just class instances, by using ==. There are rules that define when built-in datatypes 
			are considered equal; for instance, dictionaries are equal when they have all the same keys and values, and strings are equal when they are the same length and contain the same sequence of characters. 
			For class instances, you can define the __cmp__ method and code the comparison logic yourself, and then you can use == to compare instances of your class and Python will call your __cmp__ special 
			method for you.	 -tip- 比较运算
			- __len__ is called when you call len(instance). The len function is a built-in function that returns the length of an object. It works on any object that could reasonably be thought of as having a length. 
			The len of a string is its number of characters; the len of a dictionary is its number of keys; the len of a list or tuple is its number of elements. For class instances, define the __len__ method and code the 
			length calculation yourself, and then call len(instance) and Python will call your __len__ special method for you.
			- __delitem__ is called when you call del instance[key], which you may remember as the way to delete individual items from a dictionary. When you use del on a class instance, Python calls the __delitem__ 
			special method for you.
	
		In Java, you determine whether two string variables reference the same physical memory location by using str1 == str2. This is called object identity, and it is written in Python as str1 is str2. 
		To compare string values in Java, you would use str1.equals(str2); in Python, you would use str1 == str2. Java programmers who have been taught to believe that the world is a better place 
		because == in Java compares by identity instead of by value may have a difficult time adjusting to Python's lack of such “gotchas”. 
		PS: python中比较内存地址用is，比较字符串相同用==，区别去java的方式

		Special methods mean that any class can store key/value pairs like a dictionary, just by defining the __setitem__ method. Any class can act like a sequence, just by defining the __getitem__ method. 
		Any class that defines the __cmp__ method can be compared with ==. And if your class represents something that has a length, don't define a GetLength method; define the __len__ method and use len(instance).

		While other object-oriented languages only let you define the physical model of an object (“this object has a GetLength method”), Python's special class methods like __len__ allow you to define the logical 
		model of an object (“this object has a length”).

		Python has a lot of other special methods. There's a whole set of them that let classes act like numbers, allowing you to add, subtract, and do other arithmetic operations on class instances. (The canonical example 
		of this is a class that represents complex numbers, numbers with both real and imaginary components.) The __call__ method lets a class act like a function, allowing you to call a class instance directly. And there are 
		other special methods that allow classes to have read-only and write-only data attributes; you'll talk more about those in later chapters.

	5.8. Introducing Class Attributes
		